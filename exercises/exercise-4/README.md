# Упражнение №4
Зад.1. Да се напише функция (sublist? lst1 lst2), която проверява дали списъкът lst1 е подсписък на lst2 (аналогична на проверката за подстринг):
(sublist? '(2 3 4) '(1 2 3 4 5)) -> #t
(sublist? '(2 3 5) '(1 2 3 4 5)) -> #f ; тъй като търсените елементи не са последователни
(sublist? '(4 3 5) '(1 2 3 4 5)) -> #f
(sublist? '() '()) -> #t ;(!)

Упътване: можете да използвате помощна функция (begins-with? lst1 lst2), която да проверява дали списъка lst2 "започва със" списъка lst1:
(begins-with? '(2 3 4) '(2 3 4 5)) -> #t
(begins-with? '(2 3 4) '(2 3)) -> #f ;(!)

Зад.2. Да се напише функция (make-set lst), която взима произволен списък (вида на елементите му няма значение) и връща списък от същите елементи, без повторения.
Последователността на елементите в резултата няма значение, не се гони и сложност по време.
(make-set '(1 2 2 4 3 2 1 3)) -> '(1 2 4 3)                                 ; или друга тяхна пермутация
(make-set '("iei" 10 "oops" "iei" #t #t 10 #f)) -> '("iei" 10 "oops" #t #f) ; или друга тяхна пермутация

Зад.3. Да се напише функция (histogram lst), която взима произволен списък и връща списък от наредени двойки, представляващи всеки различен елемент на списъка lst, заедно с броя негови срещания в списъка:
(histogram '(a b b d c b a c)) -> '((a . 2) (b . 3) (d . 1) (c . 2)) ; отново подредбата няма значение

Зад.4. Да се напише функция (transpose m), която транспонира дадена матрица.
(transpose '((1 2 3) (4 5 6))) -> '((1 4)
                                    (2 5)
                                    (3 6))
