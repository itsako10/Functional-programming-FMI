# Упражнение №3
Зад.0. Да се имплементират вградените функции length, reverse, map и filter.

Зад.1. Да се напише функция (nth n lst), която взима n-тия елемент на даден списък:
(nth 0 '(1 2 3)) -> 1
(nth 5 '(1 2 3)) -> #f

Зад.2. Да се напише функция (range from to), която връща списъка с естествени числа в интервала [from;to]:
(range 5 10) -> '(5 6 7 8 9 10)

Зад.3. Да се напише функция (digit-list n), която връща цифрите на число в списък:
(digit-list 1806) -> '(1 8 0 6)

Зад.4. Да се напише функциите (take n lst) и (drop n lst), който съответно взимат или премахват първите n елемента на списък:
(take 3 (range 1 5)) -> '(1 2 3)
(take 10 (range 1 5)) -> '(1 2 3 4 5)
(drop 3 (range 1 5)) -> '(4 5)
(drop 10 (range 1 5)) -> '()

Зад.5. Да се напишат функциите (all? p? lst) и (any? p? lst), които проверяват съответно дали всички или някои елементи на даден списък изпълняват предиката p?:
(all? even? '(1 2 3 4 5)) -> #f
(any? even? '(1 2 3 4 5)) -> #t
(any? (lambda (x) (> x 10)) '(4 2 6 3 1)) -> #f

Зад.6. Да се напише функция (zip lst1 lst2), която приема два списъка и връща списък от наредени двойки от техните съответни елементи:
(zip '(1 2 3 4) '(#t #f #f)) -> '((1 . #t) (2 . #f) (3 . #f))

Зад.7. Да се напише функция (zipWith f lst1 lst2), която връща списъка, получен от прилагането на f върху съответните елементи на двата списъка lst1 и lst2.
(zipWith + '(1 2 3 4) '(7 10 12)) -> '(8 12 15)
Каква е връзката между zip и zipWith?

Зад.8. Да се напише функция (sorted? lst), която проверява дали списък е сортиран в ненамаляващ ред.

Зад.9. Да се напише функция (uniques lst), която оставя само уникалните стойности в даден списък. Можете да проверявате за еднаквост с equal? за най-сигурно.
(uniques '(1 2 2 "iei" 1 3 "iei" 'oops)) -> '(1 2 "iei" 3 'oops) ; подредбата в резултата няма значение

Зад.10. Да се напише функция (extract-ints lst), която взема списък с произволни обекти и връща списък, съставен само от числата в него:
(extract-ints '(1 2 #t "Hello" (3 "no") #f 4 (5))) -> (1 2 4)

Зад.11. Да се напише функция (insert val lst), която вмъква стойността val на правилното място в сортирания в ненамаляващ ред списък lst:
(insert 5 '(1 4 10)) -> '(1 4 5 10)
(insert 12 '(1 4 10)) -> '(1 4 10 12))

Зад.12. Да се напише функция (insertion-sort lst), която прави точно това, което подсказва името ѝ:
(insertion-sort '(4 3 6 2 1 8 10)) -> '(1 2 3 4 6 8 10)

Зад.13. Да се напише функция с произволен брой аргументи (my-arity . xs), която при всяко извикване връща броя на подадените ѝ аргументи:
(my-arity 1 2 #f "iei" (3 5)) -> 5

Зад.14. Да се напише функция (compose . fns), която приема произволен брой функции като аргументи и връща тяхната композиция:
(define (sq x) (* x x))
(define (1+ x) (+ x 1))
(define f (compose sq 1+ (lambda (x) (* x 2)) 1+))
; това е екв. на: (sq
                     (1+
                        ((lambda (x) (* x 2))
                                             (1+ 5))))
(f 5) -> 169

Зад.15*. Да се напише функция (group-by f lst), която групира елементите на списъка lst по стойността, която f връща за тях:
(group-by even? '(1 2 3 4 5)) -> ((#f (1 3 5))
                                  (#t (2 4))) ; подредбата няма значение
(group-by length '((1 2 3) (4) (5 6 7))) -> '((1 ((4)))
                                              (3 ((1 2 3) (5 6 7))))

Зад.16***. Да се напише функция (zipWith* f . lsts),  която работи аналогично на zipWith, но с произволен брой списъци като аргументи:
(zipWith* list '(1 2 3) '(a b) '(7 8 9 10)) -> '((1 a 7) (2 b 8))
(zipWith* + '(1 2 3)) -> '(1 2 3) ; все пак броят списъци е произволен
(zipWith* void) -> '() ; why does this make my head hurt
Упътване: можете да подавате аргументи на такъв тип функции с apply: (apply + 2 3 5) <=> (+ 2 3 5) -> 10
